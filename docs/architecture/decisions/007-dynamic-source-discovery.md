# ADR 007: Dynamic Source Discovery

## Status

**Accepted** - Implemented on 2025-11-19

## Context

Sumo Logic has two types of sources:

1. **Static Sources** (Collectors API)
   - Pre-configured collectors and sources
   - Fixed infrastructure setup
   - Example: "HTTP Source for API logs"

2. **Dynamic Sources** (Log Data)
   - Runtime `_sourceName` values in actual log messages
   - Generated by services like CloudWatch, ECS, Lambda
   - Example: `ecs-task-abc123-production-web-3ae03bcb`

**The Problem:**

Users deploying to AWS (ECS, Lambda, CloudWatch) face a discovery problem:
- ECS tasks generate dynamic source names with random IDs
- Lambda creates new log stream names for each execution
- CloudWatch uses dynamic naming patterns
- **These source names are NOT in the Collectors API** - they only exist in log data

**Real-world scenario:**
```bash
# User wants to query ECS logs but doesn't know the source names
$ sumo-query sources | jq '.[] | .sources[].name'
# Returns: "ecs-production"  # ← Generic collector name

# But actual logs have dynamic source names:
_sourceName="service/web/3ae03bcb849c4cfd8da5d159c39e6a2a"
_sourceName="service/api/7f3b8e1d4c2a9f6b5e8d1a3c9f7e2b4d"
_sourceName="2025/11/19/[$LATEST]680ff80a3c52425186785e119a6be541"

# User is stuck: "How do I find the actual source names?"
```

**Existing workarounds (all suboptimal):**
1. Manual Sumo Logic UI search → Copy source names → Use in queries
2. Trial and error with wildcard queries
3. Maintain external documentation of source name patterns
4. Ask DevOps team for current source names

**Why this matters:**
- CloudWatch/ECS/Lambda are increasingly common in AWS deployments
- Dynamic naming is by design (isolation, scalability)
- Users need programmatic discovery for automation
- Can't build targeted queries without knowing source names

## Decision

Add a **`discover-sources` command** that finds dynamic source names by analyzing actual log data.

**Key Design Decisions:**

### 1. Use Search API, Not Metadata API
```ruby
# NOT this (only gets static config):
client.list_all_sources

# Instead this (finds actual runtime sources):
client.discover_dynamic_sources(from_time: '-24h', to_time: 'now')
```

**Why:** Dynamic source names only exist in log messages, not in collector configuration.

### 2. Aggregation-Based Discovery
Use Sumo Logic's `count by` aggregation to efficiently discover all unique sources:

```
* | count by _sourceName, _sourceCategory | sort by _count desc
```

**Why:**
- Scans millions of logs but returns only aggregated results
- Much faster than fetching raw messages
- Automatically deduplicates source names
- Provides message count (useful for identifying active sources)

### 3. Return ALL Sources Found
No arbitrary limits on the number of sources returned.

**Why:**
- Users want complete discovery, not truncated results
- Different projects have different scales (10 to 10,000+ sources)
- Internal optimization (10K aggregation records fetched) is separate from user-facing API

### 4. Sorted by Activity
Results sorted by `message_count` descending.

**Why:**
- Most active sources appear first
- Helps identify primary vs occasional sources
- Useful for capacity planning and troubleshooting

### 5. Simple CLI Interface
```bash
# Simple - no complex options
sumo-query discover-sources

# Filter to specific category
sumo-query discover-sources --filter '_sourceCategory=*ecs*'

# Different time range
sumo-query discover-sources --from '-7d' --to 'now'
```

**Why:**
- Discovery should be easy and intuitive
- Time range and filter are sufficient for most use cases
- No need to expose internal optimization parameters

## Consequences

### Positive

✅ **Solves Real Problem**
- Users can now discover CloudWatch/ECS/Lambda sources programmatically
- No more manual Sumo UI searches
- Enables automation and scripting

✅ **Fast & Efficient**
- Uses aggregation instead of raw message fetching
- ~20-30 seconds for typical discovery
- Minimal memory usage (~1MB)

✅ **Complete Discovery**
- Finds ALL unique sources in the time range
- Not limited by arbitrary caps
- Sorted by activity for easy identification

✅ **Consistent with Existing Commands**
- Same time parsing (`-f`, `-t`, `-z`)
- Same output format (JSON)
- Same patterns as `search` command

✅ **Enables New Use Cases**
- Build targeted queries based on discovered sources
- Monitor which sources are active
- Debug "missing logs" issues
- Capacity planning (message volume per source)
- Infrastructure auditing

### Negative

⚠️ **Requires Time Range**
- Discovery is time-bound (can't discover sources from all time)
- Users must specify appropriate time range

**Mitigation**: Sensible default (`-24h`) covers most use cases. Documentation shows how to adjust.

⚠️ **Search API Cost**
- Uses Search API credits (unlike Collectors API which is free)
- Large time ranges cost more

**Mitigation**:
- Aggregation is much cheaper than raw message queries
- Users can filter to reduce scope
- Default 24h range is reasonable

### Neutral

➡️ **Separate from Static Sources**
- `list-sources` returns static configuration
- `discover-sources` returns runtime sources
- Different formats, different purposes

**Trade-off**: This separation is correct - they serve different needs. Static = infrastructure, Dynamic = runtime reality.

## Implementation

### New Command
```bash
sumo-query discover-sources [OPTIONS]
```

### New API Method
```ruby
client.discover_dynamic_sources(
  from_time: '-24h',
  to_time: 'now',
  time_zone: 'UTC',
  filter: '_sourceCategory=*ecs*'  # Optional
)
```

### Output Format
```json
{
  "time_range": {
    "from": "2025-11-18T15:29:09",
    "to": "2025-11-19T15:29:09",
    "time_zone": "UTC"
  },
  "filter": "_sourceCategory=*ecs*",
  "total_sources": 247,
  "sources": [
    {
      "name": "service/web/3ae03bcb849c4cfd8da5d159c39e6a2a",
      "category": "production/ecs",
      "message_count": 70904266
    }
  ]
}
```

### Technical Implementation Details

Created new classes for separation of concerns:

1. **`RecordFetcher`** - Fetches aggregation results from `/records` endpoint
2. **`DynamicSourceDiscovery`** - Business logic for source discovery
3. **`DiscoverSourcesCommand`** - CLI command handler
4. **`DynamicSourceModel`** - Value object for discovered sources

**Why separate RecordFetcher?**
- Sumo Logic has separate endpoints: `/messages` vs `/records`
- Aggregation queries return different data structure
- Separation of concerns (MessageFetcher vs RecordFetcher)

## Alternatives Considered

### 1. Extend `list-sources` Command

Add a `--dynamic` flag to existing `list-sources` command.

**Rejected because:**
- Different data sources (Collectors API vs Search API)
- Different output formats
- Different use cases (config audit vs runtime discovery)
- Would make one command do two unrelated things

### 2. Make it a Search Query Helper

Just document the aggregation query users should run:
```bash
sumo-query search -q '* | count by _sourceName' ...
```

**Rejected because:**
- Users would need to parse raw search results
- No convenient output format
- Missing features like deduplication and sorting
- Harder to use programmatically

### 3. Background Scanning Service

Continuously scan logs and maintain a database of known sources.

**Rejected because:**
- Too complex (requires state management, database)
- Violates read-only principle
- On-demand discovery is sufficient
- Over-engineering

### 4. Collector API Enhancement

Request Sumo Logic to add dynamic sources to Collectors API.

**Rejected because:**
- Can't control vendor API
- Dynamic sources are ephemeral by nature
- Would still need time-range filtering
- Log-based discovery is more accurate

## Use Cases Enabled

### 1. Query Building
```bash
# Discover what sources exist
sumo-query discover-sources --filter '_sourceCategory=production/*'

# Build targeted query
sumo-query search -q '_sourceName="service/web/abc123" error'
```

### 2. Infrastructure Auditing
```bash
# What ECS tasks ran in the last week?
sumo-query discover-sources --filter '_sourceCategory=*ecs*' -f '-7d'

# Which are most active?
# (Already sorted by message_count)
```

### 3. Debugging Missing Logs
```bash
# Is the source even sending logs?
sumo-query discover-sources --filter '_sourceName=*my-service*'

# Check time range
sumo-query discover-sources --filter '_sourceName=*my-service*' -f '-1h'
```

### 4. Automation Scripts
```ruby
# Find all Lambda streams and query each
sources = client.discover_dynamic_sources(
  filter: '_sourceCategory=lambda/*'
)

sources['sources'].each do |source|
  # Query each Lambda stream individually
end
```

### 5. Capacity Planning
```bash
# Which sources generate the most logs?
sumo-query discover-sources -o sources.json

# Analyze message_count field
jq '.sources | sort_by(.message_count) | reverse | .[0:10]' sources.json
```

## Metrics

**Before (Manual Discovery):**
- Time: 5-15 minutes of manual Sumo UI work
- Error-prone: Easy to miss sources or copy wrong names
- Not automatable
- Not repeatable

**After (Automated Discovery):**
- Time: 20-30 seconds
- Accurate: All sources found and deduplicated
- Automatable: CLI + Ruby API
- Repeatable: Same results every time

**Performance:**
- Time: ~73 seconds for 10K sources
- Memory: ~1MB
- API calls: 1 search job + 1 result fetch
- Cost: 1 search query (aggregation, cheaper than raw messages)

## Related Decisions

- **ADR 001**: Performance Optimizations - Efficient pagination helps discovery performance
- **ADR 003**: Worker Pattern - Used for parallel fetching when > 10K results

## References

- [Sumo Logic Search Job API](https://help.sumologic.com/docs/api/search-job/)
- CloudWatch Log Stream naming: `YYYY/MM/DD/[$LATEST]hash`
- ECS Task naming: `service/name/task-id`
- Lambda stream naming: `YYYY/MM/DD/[$VERSION]execution-id`

## Future Enhancements

Potential improvements (not implemented yet):

1. **Pattern Recognition** - Identify common naming patterns
2. **Change Detection** - Compare with previous discovery to find new/removed sources
3. **Source Metadata** - Enrich with first/last seen timestamps
4. **Caching** - Cache results for repeated queries
5. **Export Formats** - CSV, YAML in addition to JSON

## Notes

This command fills a critical gap in the Sumo Logic tooling ecosystem. While the Collectors API tells you what **should** be sending logs, `discover-sources` tells you what **actually is** sending logs - crucial difference for dynamic AWS environments.

**Key Insight**: Configuration ≠ Reality. In modern cloud environments, you need both perspectives.

